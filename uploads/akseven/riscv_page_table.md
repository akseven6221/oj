首先来个简单的入门
- 每个应用都有属于自己的一个页表, 不同用户程序的页表是不同的, 这里说的页表是指一整个三级分页, 不同的用户程序对应的satp寄存器不一样
  这就使得一个地址可以被不同的程序复用(这里指的地址是指虚拟地址)



Linux内核加载ELF可执行文件的基本步骤：

1. 读取并验证ELF头
2. 加载程序头表
3. 为每个可加载段（PT_LOAD）创建内存映射
4. 设置入口点
5. 初始化寄存器并跳转到入口点开始执行


### 1. **进程树（Process Tree）的结构**
   • 在Unix/Linux系统中，所有进程构成一棵树状结构，**用户初始进程（通常是`init`或现代系统中的`systemd`，PID=1）是这棵树的根节点**。
   • 当一个进程（父进程）创建子进程时，子进程会挂在父进程的下方。例如：
```
  init (PID=1)
  └─ bash (PID=1000)
      └─ sleep (PID=1001)  # 子进程
```

---

### 2. **父进程先于子进程终止时会发生什么？**
   • 如果父进程（例如上例中的`bash`）**先于子进程（`sleep`）终止**，子进程会失去父进程，变成**孤儿进程**。
   • 操作系统为了解决孤儿进程的资源回收问题，会**自动将这些孤儿进程的父进程重置为`init`（PID=1）**。此时进程树变为：
```
init (PID=1)
├─ ... (其他进程)
└─ sleep (PID=1001)  # 原父进程已终止，现在被init接管
```
   • 这就是你提到的“子进程成为进程树的根节点的子进程”的含义。这里的**根节点**就是`init`进程（PID=1），而子进程被挂到`init`的直接下级。

---

### 3. **关键概念澄清**
   • **根节点（Root of Process Tree）**：特指`init`或`systemd`（PID=1），它是所有进程的最终祖先。
   • **子进程的父进程转变**：孤儿进程的父进程ID（PPID）会被内核修改为1，而不是保持原来的已终止父进程。
   • **资源回收**：`init`进程会定期调用`wait()`系统调用，回收这些孤儿进程的退出状态（避免僵尸进程），并释放其资源。

---

### 4. **为什么需要`init`接管？**
   • **防止僵尸进程**：如果孤儿进程不被接管，它们终止后可能无人回收（变成僵尸进程）。
   • **统一管理**：`init`作为系统的第一个进程，有责任维护进程树的完整性。

---

### 你的疑问解答
> “子进程变成进程树的根节点”是什么意思？

这里的表述可能不够准确。正确的理解是：
• **子进程不会变成根节点**，而是被**挂到根节点（`init`）的直接下级**。
• 例如：
  • 原结构：`A → B`（A是父进程，B是子进程）。
  • A终止后：`init → B`（B的父进程变成`init`）。

---

### 总结
当父进程先于子进程终止时：
1. 子进程的父进程会被强制改为`init`（PID=1）。
2. `init`成为这些子进程的新父进程，负责后续的资源回收。
3. 子进程并未成为“根节点”，而是被挂到了根节点`init`的下方。

这个过程是操作系统对孤儿进程的标准化处理机制，确保系统资源的正确释放。





好的！我用一个具体的例子来模拟 **父进程等待子进程退出** 的场景，对比 **忙等待（不主动让出CPU）** 和 **`yield_`主动让出CPU** 的区别。假设我们有一个单核CPU，并且只有时间片中断调度（比如每10ms强制切换一次进程）。

---

### **场景设定**
1. **进程**：
   • **父进程（P1）**：调用 `waitpid` 等待子进程退出。
   • **子进程（P2）**：执行一个耗时操作（比如计算或I/O），需要 **30ms** 才能退出。
2. **CPU调度规则**：
   • 每个进程最多运行 **10ms**（时间片），然后被强制切换。
   • 如果进程主动调用 `yield_`，会立即让出CPU。

---

### **情况1：父进程忙等待（不调用 `yield_`）**
• **时间线**：
  | 时间 (ms) | 运行的进程 | 事件 |
  |-----------|------------|------|
  | 0-10      | P1（父进程） | P1 调用 `waitpid`，发现 P2 未退出（返回 `-2`），继续循环调用 `waitpid`（占用CPU）。 |
  | 10-20     | P1（父进程） | P1 再次调用 `waitpid`，P2 仍未退出（继续空转）。 |
  | 20-30     | P1（父进程） | P1 继续空转，P2 始终未得到CPU时间。 |
  | 30-40     | P2（子进程） | **终于轮到 P2 运行**，P2 开始执行并退出。 |
  | 40-50     | P1（父进程） | P1 调用 `waitpid`，发现 P2 已退出，回收资源。 |

• **问题**：
  • 在 **0-30ms** 期间，父进程 P1 一直占着CPU空转，而子进程 P2 直到 **30ms** 才第一次运行。
  • **实际等待时间：40ms**（因为 P2 直到 30ms 才执行，40ms 才被回收）。
  • **CPU浪费**：前 30ms CPU 一直在做无意义的轮询（P1 空转），而真正需要运行的 P2 被延迟。

---

### **情况2：父进程调用 `yield_` 主动让出CPU**
• **时间线**：
  | 时间 (ms) | 运行的进程 | 事件 |
  |-----------|------------|------|
  | 0-10      | P1（父进程） | P1 调用 `waitpid`，发现 P2 未退出（返回 `-2`），**立即调用 `yield_` 让出CPU**。 |
  | 10-20     | P2（子进程） | P2 开始运行，执行耗时操作（还剩 20ms）。 |
  | 20-30     | P2（子进程） | P2 继续运行（还剩 10ms）。 |
  | 30-40     | P2（子进程） | P2 完成操作并退出。 |
  | 40-50     | P1（父进程） | P1 被重新调度，调用 `waitpid`，发现 P2 已退出，回收资源。 |

• **优化效果**：
  • P1 在第一次 `waitpid` 失败后立即让出CPU，P2 **立刻获得CPU时间**。
  • **实际等待时间：40ms**（和忙等待一样），但 **P2 提前完成**（30ms 退出，而不是被延迟到 30ms 才启动）。
  • **CPU利用率**：
    ◦ 前 10ms：P1 检查一次后主动让出CPU。
    ◦ 后续时间全部用于 P2 的执行，**没有空转**。

---

### **关键区别**
| 行为                | 忙等待                     | 主动 `yield_`               |
|---------------------|---------------------------|----------------------------|
| **父进程占用CPU**    | 一直空转，直到时间片耗尽   | 检查一次后立即让出CPU       |
| **子进程执行时机**   | 被延迟（父进程占着CPU）    | 立刻获得CPU时间             |
| **实际等待时间**     | 较长（子进程被推迟运行）   | 更短（子进程尽早执行）      |
| **CPU浪费**          | 高（父进程空转）           | 低（CPU时间全用于有效工作） |

---

### **类比理解**
想象你和朋友一起用一台电脑（单核CPU）：
• **忙等待**：你一直盯着屏幕问朋友“你好了没？”（占用电脑），朋友根本没机会用电脑，直到你问累了（时间片耗尽）才把电脑给他。
• **`yield_`**：你问一次“你好了没？”，朋友说“没”，你直接把电脑给他用。他用完后再还给你。

显然，第二种方式效率更高！

---

### **总结**
在单核CPU中：
• 如果父进程不主动让出CPU（忙等待），子进程会被“饿死”，导致整体等待时间变长。
• 通过 `yield_` 主动让出CPU，子进程能更快执行，**减少父进程的空等时间**，从而提升系统效率。  
这就是为什么 `yield_` 能减少CPU浪费！


- ch5里系统是通过main函数进入的，然后执行add_initproc，整个taskManager里就一个initproc任务，再用一个空任务切换到这个initproc执行，然后initproc再通过
  fork+exec执行shell，正式进入shell.